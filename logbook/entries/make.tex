\section{Make}

Make is a build automation tool that also documents our workflow. A basic make file declares a set of inputs, a set of outputs, and the recipes by which output get produced from inputs. A recipe for an output declares all its inputs (e.g., data files) and the code files that generate the output from the inputs. Just like real recipe it tells us what we need to produce the output we want.

In this way Make documents the dependencies between the files in our project folder. If you want to know how outputs are made from inputs, you just need to look at the make file. Makefiles are machine-readable documentation that make your workflow reproducible.

To execute a makefile run go to the directory and type \texttt{make} in the command line. That's it. Make will execute all the recipes and produce outputs from inputs.

If you execute \texttt{make} again (try it), it won't do anything. Why? Because make sees that the outputs are more recent than their dependencies (inputs). From this fact it infers that no dependency has changed since the last execution of \texttt{make}. And since no dependency has changed, the output would also not change. So it is a waste of our time to run everything again. Make only reruns a recipe if its dependencies have changed more recently than its outputs.

By using Make throughout our project we make sure that whenever we make a code change, then the downstream tasks (and only the downstream tasks) are updated as well.

\subsection{Learn Make}

Make is not a particularly transparent language, but we tend to use only its basic functionality. The following resources are helpful:

\begin{itemize}
\item Mike Bostock: \href{https://bost.ocks.org/mike/make/}{Why Use Make}
\item Software Carpentry's \href{http://swcarpentry.github.io/make-novice/}{Introductory Make class}
\item Karl Broman: \href{http://kbroman.org/minimal_make/}{minimal make}
\item Kieran Healy: \href{http://plain-text.co/pull-it-together.html}{Pull It Together} (The Plain Person's Guide to Plain Text Social Science)
\item Zachary M. Jones: \href{http://zmjones.com/make/}{GNU Make for Reproducible Data Analysis}
\item The \href{https://www.youtube.com/watch?v=_Ms1Z4xfqv4}{first fifteen minutes of Lecture 8} in MIT's ``Missing Semester'' CS class are a nice introduction to Make.
\end{itemize}


\subsection{Writing Makefiles}

Below is an example of a simple makefile. Most make files we want to write have a similar structure.

\begin{lstlisting}[language=make]
## Definitions

# Folders we will be looking for in the task directory
folders := ../input ../output

# This generates the list of zip files we should see in the input folder 	
input=  ../input/fmliquarterly.parquet \
		../input/mtbimonthly.parquet 

# This generates the list of processed data files and figures
output=   ../output/cohort_graph.png 

## Recipes
all: $(folders) $(input) $(output)

# Create folders if they do not already exist
$(folders):
	mkdir $@

# Create symbolic links
../input/fmliquarterly.parquet ../input/mtbimonthly.parquet: | ../input
	if [ -e ../../createconsumptionvariables/output/$(@F) ] ; then ln -s ../../createconsumptionvariables/output/$(@F) $@ ; else exit 1; fi	

# this is the recipe that creates the png file
../output/cohort_graph.png: cohortgraph.py  $(input)
	python3 $<
\end{lstlisting}

\begin{itemize}
	\item The first three lines of code (excluding comments) declare variables using \texttt{:=}
	\begin{itemize}
		\item \texttt{folders} are the folders we want to create if they do not already exist. These are \texttt{../input ../output} where \texttt{../} indicates they exist in the directory just above the current directory.
		\item \texttt{inputs} are the dependencies. These are the data files we need to create the outputs. Note that we are looking for these files in the input folder. The backslash \texttt{\\} indicates a line break, so we can stack the input files rather than putting them all on one line.
		\item \texttt{outputs} the outputs we want to produce.
	\end{itemize}
	\item The next set of lines tell make how the outputs are produced from the inputs.
	\begin{itemize}
		\item \texttt{all:} lists all the targets that Make has to create. 
		\item \texttt{\$(folders): mkdir \$@}. This is a recipe for creating folder. To create the folders \texttt{../input ../output} (stored in the variable folders) we want to execute the command \texttt{mkdir ../input ../output}. Make interprets the placeholder \texttt{\$@} as the file name of the target.
		\item The next line creates symbolic links. We produced the files mtbimonthly.parquet as part of a different task, so they are in the output folder of that tasks. 
		
		In this case the file is located in ../../createconsumptionvariables/output/mtbimonthly.parquet.
		
		Rather than copying the file and duplicating storage, we put a symbolic link to the file into our ../input path. This is done by \texttt{ln -s}.
		
		The if statement checks whether the file we want to link to does in fact exist.
		\item \texttt{../output/cohort\_graph.png: cohortgraph.py  \$(input)} tells make that to produce ../output/cohort\_graph.png it needs both cohortgraph.py and the set of inputs contained in the input variable. If any of these dependencies gets updated Make knows it needs to recreate the output.
		
		If Make does see that the dependencies have changed, it will execute the lines below the recipe. In this case, \texttt{python3 \$<} or, equivalently, \texttt{python3 cohortgraph.py}.
		
		\item Note that in each of the three cases, the commands that create the outputs are indented. Make will keep executing indented code lines of a recipe until the indentation stops. This allows you to run multiple scripts in sequence to produce any given output.
	\end{itemize}
\end{itemize}

Common placeholders in makefiles:
\begin{itemize}
	\item \texttt{\$@}	File name of the rule's target
	\item \texttt{\$<}	File name of the first prerequisite
\end{itemize}

%$@	File name of the rule's target
%$%	The target member's name, if the rule's target is an archive
%$<	File name of the first prerequisite
%$^	List of all prerequisites
%$?	List of all prerequisites that are newer than the target
%$*	The "stem" of an implicit or pattern rule

